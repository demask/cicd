import jenkins.*;
import jenkins.model.*;

// List all project paths for which git commit is watched
def jobsByProjectPath = [
    "job1/": "job1",
    "job2/": "job2_1",
    "job3/": "job3"
  ]

// Find all jobs for project paths in which git commit happend
def jobsToRun(build, jobsByProjectPath) {
  // Listing changes files since last build
  def changeLogSets = build.changeSets
  def changedFiles = []
  for (int i = 0; i < changeLogSets.size(); i++) {
    def entries = changeLogSets[i].items
    for (int j = 0; j < entries.length; j++) {
      def entry = entries[j]
      def files = new ArrayList(entry.affectedFiles)
      for (int k = 0; k < files.size(); k++) {
        def file = files[k]
        changedFiles.add(file.path)
      }
    }
  }

  // Listing jobs to run
  jobsToRun = [:]
  for (entry in jobsByProjectPath) {
    def pattern = entry.key
    for (int i = 0; i < changedFiles.size(); i++) {
      def file = changedFiles[i]
      if (file.contains(pattern)) {
        def jobName = entry.value
        jobsToRun[jobName] = true
        break
      }
    }
  }

  jobsToRun
}

def cloneGitRepo(merged_into_branch) {
  stage('Cloning Git') {           
    checkout([
      $class: 'GitSCM', 
      branches: [[name: "*/$merged_into_branch"]], 
      doGenerateSubmoduleConfigurations: false, 
      extensions: [[$class: 'RelativeTargetDirectory', relativeTargetDir: 'code_directory']], 
      submoduleCfg: [], 
      userRemoteConfigs: [[credentialsId: '', url: 'https://github.com/demask/aws_codebuild_codedeploy_nodeJs_demo.git']]])                 
  }

  stage('Cloning Terraform Git') {           
    checkout([
      $class: 'GitSCM', 
      branches: [[name: '*/master']], 
      doGenerateSubmoduleConfigurations: false, 
      extensions: [[$class: 'RelativeTargetDirectory', relativeTargetDir: 'terraform_directory']], 
      submoduleCfg: [], 
      userRemoteConfigs: [[credentialsId: '', url: 'https://github.com/demask/aws_codebuild_codedeploy_nodeJs_demo_terraform.git']]])                 
  } 
}

def runTerraform(dockerImageTag) {
  stage('Terraform Init') {     
    sh 'terraform init -no-color'
  }
                
  stage('Terraform Apply') {     
    sh ("""terraform apply \
    -var=\"docker_image_tag=${dockerImageTag}\" \
    -auto-approve -no-color""")
  }
}

def createTaskDefinitions(newDockerImageMap, merged_into_branch) {
  def jobAlreadyCreated = false
  def terraformDirectoryByEnvironment = "dev"
  if(merged_into_branch == "develop") {
    terraformDirectoryByEnvironment = "dev"
  }

  newDockerImageMap.each{
    if(!jobAlreadyCreated && (it.key == 'job2_1' || it.key == 'job2_2')) {
      dir("${env.WORKSPACE}/terraform_directory/${terraformDirectoryByEnvironment}/ecs-service/job2"){
        runTerraform(it.value)     
      } 

      jobAlreadyCreated = true
    } else if(it.key != 'job2_1' && it.key != 'job2_2') {
      dir("${env.WORKSPACE}/terraform_directory/${terraformDirectoryByEnvironment}/ecs-service/${it.key}"){
        runTerraform(it.value)     
      } 
    }
  }
}

def buildDockerImage(IMAGE_TAG, IMAGE_REPO_NAME, DOCKERFILE, AWS_ACCOUNT_ID, AWS_DEFAULT_REGION, newDockerImageMap) {
  def REPOSITORY_URI = "${AWS_ACCOUNT_ID}.dkr.ecr.${AWS_DEFAULT_REGION}.amazonaws.com/${IMAGE_REPO_NAME}"

  stage('Building image') {
    dockerImage = docker.build("${IMAGE_REPO_NAME}:${IMAGE_TAG}", "-f ${DOCKERFILE} .")                         
  }
   
  stage('Push image to ECR') {         
    sh "docker tag ${IMAGE_REPO_NAME}:${IMAGE_TAG} ${REPOSITORY_URI}:${IMAGE_TAG}"
    sh "docker push ${AWS_ACCOUNT_ID}.dkr.ecr.${AWS_DEFAULT_REGION}.amazonaws.com/${IMAGE_REPO_NAME}:${IMAGE_TAG}"                            
  }

  newDockerImageMap[IMAGE_REPO_NAME] = IMAGE_TAG
}

def createAndPushDockerImages(currentBuild, jobsByProjectPath, AWS_ACCOUNT_ID, AWS_DEFAULT_REGION, merged_into_branch) {
  def newDockerImageMap = [:]
  dir("${env.WORKSPACE}/code_directory"){  
    def jobs
    stage('Check jobs to run') { 
      jobs = jobsToRun(currentBuild, jobsByProjectPath)
      addPhpIfNginxPresent(jobs)
    }
    
    def IMAGE_TAG = sh (script: 'git rev-parse --short HEAD',returnStdout: true).trim()
    if(merged_into_branch == "develop") {
      IMAGE_TAG = "dev_" + IMAGE_TAG
    } else if(merged_into_branch == "master") {
      IMAGE_TAG = "prod_" + IMAGE_TAG
    }

    jobs.each{
      def DOCKERFILE
      def IMAGE_REPO_NAME
      if(it.key) {
        IMAGE_REPO_NAME = it.key
      }

      if(it.key == 'job1' && it.value) {
        DOCKERFILE = 'Dockerfile'
      } else if(it.key == 'job3' && it.value) {
        DOCKERFILE = 'DockerfileJob3'
      } else if(it.key == 'job2_1' && it.value) {
        DOCKERFILE = 'Dockerfile'
      } else if(it.key == 'job2_2' && it.value) {
        DOCKERFILE = 'Dockerfile'
      }

      if(it.key == 'job3' && it.value && DOCKERFILE && IMAGE_REPO_NAME) {
        dir("${env.WORKSPACE}/code_directory/job3"){
          buildDockerImage(IMAGE_TAG, IMAGE_REPO_NAME, DOCKERFILE, AWS_ACCOUNT_ID, AWS_DEFAULT_REGION, newDockerImageMap)
        }
      } else if(DOCKERFILE && IMAGE_REPO_NAME) {
        buildDockerImage(IMAGE_TAG, IMAGE_REPO_NAME, DOCKERFILE, AWS_ACCOUNT_ID, AWS_DEFAULT_REGION, newDockerImageMap)
      }
    } 
  }

  return newDockerImageMap
}

def addPhpIfNginxPresent(jobsToRun) {
  def nginxPresent = false
  jobsToRun.each{ 
    if(it.key == 'job2_1' && it.value) {
      nginxPresent = true
    }
  }
  if(nginxPresent) {
    jobsToRun["job2_2"] = true
  }
}

node {
  parameters {
    string(name: 'branch', defaultValue: '', description: 'Branch on which was merged', trim: true),
    string(name: 'merged', defaultValue: '', description: 'Did merge occured', trim: true),
    string(name: 'ref_type', defaultValue: '', description: 'Ref type', trim: true),
    string(name: 'tag', defaultValue: '', description: 'Tag', trim: true)
  }

  def merged_into_branch
  if("$merged" == "true" || $ref_type" == "tag") {
    
    if("$merged" == "true") {
      merged_into_branch = "$branch"
    } else if("$ref_type" == "tag") {
      merged_into_branch = "$tag"
    }

    def AWS_ACCOUNT_ID="246005639140"
    def AWS_DEFAULT_REGION="eu-central-1" 

    stage('Clean workspace') {      
      cleanWs()           
    }

    stage('Logging into AWS ECR') {      
      sh "aws ecr get-login-password --region ${AWS_DEFAULT_REGION} | docker login --username AWS --password-stdin ${AWS_ACCOUNT_ID}.dkr.ecr.${AWS_DEFAULT_REGION}.amazonaws.com"           
    }
        
    cloneGitRepo(merged_into_branch)
    def newDockerImageMap = createAndPushDockerImages(currentBuild, jobsByProjectPath, AWS_ACCOUNT_ID, AWS_DEFAULT_REGION, merged_into_branch)

    if(merged_into_branch != "master") {
      createTaskDefinitions(newDockerImageMap, merged_into_branch)
    }
  }
}